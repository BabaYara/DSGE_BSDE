\documentclass[11pt,letterpaper,oneside]{article}
\usepackage[margin=1in]{geometry}

% Math & theorem stack
\usepackage{amsmath,amssymb,amsfonts,mathtools,bm,amsthm,thmtools}
\numberwithin{equation}{section}

% Boxes & graphics
\usepackage[skins,breakable,theorems]{tcolorbox}
\usepackage{graphicx}
\usepackage{tikz}
\usetikzlibrary{positioning,calc}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18}

% Formatting
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{microtype}
% Allow a bit more stretch to avoid overfull boxes
\emergencystretch=2em
\usepackage{verbatim}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{siunitx}

% Colors (load explicitly to ensure \definecolor is available on all setups)
\usepackage{xcolor}

% Code and verification helpers
% Use listings instead of minted to avoid external dependencies
\usepackage{listings}
% PythonTeX (disabled): define a lightweight 'pyconsole' as listings to avoid external deps
\lstnewenvironment{pyconsole}{\lstset{language=Python}}{}

% Acronyms: lightweight fallback to avoid package complexity
\newcommand{\ac}[1]{{\mdseries\textsc{#1}}}
\newcommand{\printacronyms}{}
\providecommand{\acswitchoff}{}

% Colors
\definecolor{darkblue}{RGB}{0,63,128}
\definecolor{darkred}{RGB}{150,0,0}
\definecolor{darkgreen}{RGB}{0,110,0}
\definecolor{boxbg}{RGB}{243,248,255}
\definecolor{boxmathbg}{RGB}{252,248,240}
\definecolor{boxlitbg}{RGB}{244,247,244}
\definecolor{sympycolor}{RGB}{0,100,0}
\definecolor{leancolor}{RGB}{120,0,150}
\definecolor{sympybg}{RGB}{240,255,240}
\definecolor{leanbg}{RGB}{252,240,255}

% TColorBox styles (required)
\tcbset{
  didacticstyle/.style={
    enhanced,breakable,skin=enhanced,
    colback=boxbg,colframe=darkblue,arc=2pt,boxrule=0.8pt,
    title=\sffamily\bfseries Pedagogical Insight: Economic Intuition \& Context,
  },
  mathstyle/.style={
    enhanced,breakable,skin=enhanced,
    colback=boxmathbg,colframe=darkgreen,arc=2pt,boxrule=0.8pt,
    title=\sffamily\bfseries Mathematical Insight: Rigor \& Implications,
  },
  literaturestyle/.style={
    enhanced,breakable,skin=enhanced,
    colback=boxlitbg,colframe=darkred,arc=2pt,boxrule=0.8pt,
    title=\sffamily\bfseries Connections to the Literature,
  }
}

\newtcolorbox{sympycheck}[1][]{enhanced,breakable,colback=sympybg,colframe=sympycolor,arc=2pt,boxrule=0.8pt,title=\sffamily\bfseries SymPy Verification,#1}
\newtcolorbox{leanproof}[1][]{enhanced,breakable,colback=leanbg,colframe=leancolor,arc=2pt,boxrule=0.8pt,title=\sffamily\bfseries Lean4 Proof,#1}

% TCB theorems with the mathstyle
\newtcbtheorem[number within=section]{assumption}{Assumption}{mathstyle}{ass}
\newtcbtheorem[number within=section]{definition}{Definition}{mathstyle}{def}
\newtcbtheorem[number within=section]{lemma}{Lemma}{mathstyle}{lem}
\newtcbtheorem[number within=section]{proposition}{Proposition}{mathstyle}{prop}
\newtcbtheorem[number within=section]{theorem}{Theorem}{mathstyle}{thm}
\newtcbtheorem[number within=section]{corollary}{Corollary}{mathstyle}{cor}

% Hyperref then Cleveref (order required)
% Note: disable PDF bookmarks to avoid stale .out parsing errors across runs
\usepackage[colorlinks=true,linkcolor=darkblue,citecolor=darkgreen,urlcolor=darkred,bookmarks=false]{hyperref}
\usepackage[nameinlink,capitalise,noabbrev]{cleveref}
% Cleveref names for tcolorbox theorems (use environment names, not internal counters)
\crefname{assumption}{Assumption}{Assumptions}
\Crefname{assumption}{Assumption}{Assumptions}
\crefname{definition}{Definition}{Definitions}
\Crefname{definition}{Definition}{Definitions}
\crefname{lemma}{Lemma}{Lemmas}
\Crefname{lemma}{Lemma}{Lemmas}
\crefname{proposition}{Proposition}{Propositions}
\Crefname{proposition}{Proposition}{Propositions}
\crefname{theorem}{Theorem}{Theorems}
\Crefname{theorem}{Theorem}{Theorems}
\crefname{corollary}{Corollary}{Corollaries}
\Crefname{corollary}{Corollary}{Corollaries}

% Note: No need to set Cleveref names for internal tcolorbox counters.

% Convenience macros
\DeclareMathOperator{\E}{\mathbb{E}}
\DeclareMathOperator{\Var}{\mathrm{Var}}
\DeclareMathOperator{\Cov}{\mathrm{Cov}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\1}{\mathbf{1}}
\newcommand{\diff}{\mathrm{d}}
\newcommand{\norm}[1]{\left\lVert #1\right\rVert}
\newcommand{\ip}[2]{\left\langle #1,\,#2\right\rangle}

% Title
\title{\vspace{-1.5em}Two Lucas Trees with Log Utility: Structured Continuous-Time Notes}
\author{\small Self-contained derivation and implementation notes}
\date{\small \today}

\begin{document}
\maketitle

\begin{abstract}
\noindent
We revisit a two-tree Lucas economy with log utility and spell out the stochastic discount factor, market price of risk, risk-neutral dynamics, and valuation PDE in a format aligned with the BSDE note series. The presentation pairs economic intuition with compact symbolic checks (SymPy) and a Lean bijection proof to balance clarity and rigor.
\end{abstract}

\tableofcontents

\newpage
\section*{Executive Summary }
\addcontentsline{toc}{section}{Executive Summary }
\begin{tcolorbox}[didacticstyle]
\textbf{Primitives.}
One representative agent maximises $\E\!\int_0^\infty e^{-\rho t}\log C_t\,\diff t$ with $C_t=D^1_t+D^2_t$. Each tree $j\in\{1,2\}$ delivers dividends following correlated geometric diffusions
\[
  \frac{\diff D^j_t}{D^j_t}=\mu_j\,\diff t+\bm{\sigma}_j^{\top}\diff \bm{W}_t,
\]
with $\bm{W}$ a $d$-dimensional Brownian motion, drift parameters $\mu_j$, and diffusion loadings $\bm{\sigma}_j$. Consumption equals the sum of dividends each instant.

\textbf{Core equations.} Two state variables suffice: aggregate consumption $C_t$ and the share $s_t=D^1_t/C_t$. Writing $\bm{\sigma}_C(s)\equiv s\bm{\sigma}_1+(1-s)\bm{\sigma}_2$ and $\mu_C(s)\equiv s\mu_1+(1-s)\mu_2$:
\begin{itemize}[leftmargin=1.25em]
  \item \textbf{Consumption dynamics:} $\diff C_t/C_t = \mu_C(s_t)\,\diff t + \bm{\sigma}_C(s_t)^{\top}\diff\bm{W}_t$.
  \item \textbf{Share dynamics:} $\diff s_t = s_t(1-s_t)\big(\mu_1-\mu_2+\bm{\sigma}_C(s_t)^{\top}(\bm{\sigma}_2-\bm{\sigma}_1)\big)\,\diff t + s_t(1-s_t)(\bm{\sigma}_1-\bm{\sigma}_2)^{\top}\diff\bm{W}_t$.
  \item \textbf{Stochastic discount factor:} $\Lambda_t=e^{-\rho t}C_t^{-1}$ with
  \[
    \frac{\diff \Lambda_t}{\Lambda_t}=-(\rho+\mu_C(s_t)-\norm{\bm{\sigma}_C(s_t)}^2)\,\diff t - \bm{\sigma}_C(s_t)^{\top}\diff \bm{W}_t.
  \]
  The short rate is $r_t=\rho+\mu_C(s_t)-\norm{\bm{\sigma}_C(s_t)}^2$ and the market price of risk is $\bm{\lambda}_t=\bm{\sigma}_C(s_t)$.
  \item \textbf{CAPM:} For any asset with diffusion $\bm{\sigma}_R$, $\E_t[\diff R_t]-r_t\,\diff t=\ip{\bm{\lambda}_t}{\bm{\sigma}_R}\,\diff t$.
\end{itemize}

\textbf{Analytical simplifications.} Log utility collapses pricing kernels to functions of $(C_t,s_t)$, and price--dividend ratios depend only on $s_t$ because prices are homogeneous of degree one in dividends. Under symmetric primitives ($\mu_1=\mu_2$, $\bm{\sigma}_1=\bm{\sigma}_2$) the share is a martingale and both trees inherit the constant multiple $1/(\rho-\mu_C)$.

\textbf{Solution routes.}
\begin{enumerate}[leftmargin=1.25em]
  \item \textbf{ODE/PDE approach:} Solve the one-dimensional boundary value problem for price--dividend ratios $f_i(s)$ induced by the risk-neutral generator for $s_t$.
  \item \textbf{Simulation or BSDE diagnostics:} Simulate the forward dynamics $(C_t,s_t)$, fit BSDE solvers for price processes, and validate against the ODE benchmark.
\end{enumerate}

\textbf{Diagnostics.} Monitor the martingale property of $\Lambda_t P^i_t+\int_0^t \Lambda_u D^i_u\,\diff u$, track numerical residuals of the $f_i$ ODE, and examine implied moments of $s_t$ relative to analytical targets. SymPy and Lean checks embedded in the appendices certify key derivations.
\end{tcolorbox}

\newpage
\section{Notation and Acronyms}

\begin{table}[ht]
  \centering
  \small
  \begin{tabular}{@{} l l p{0.62\textwidth}@{}}
  \toprule
  \textbf{Symbol} & \textbf{Type} & \textbf{Meaning} \\
  \midrule
  $D_{i,t}$ & state & Dividend of tree $i$; $i\in\{1,2\}$ \\
  $C_t$ & state & Aggregate consumption $D_{1,t}+D_{2,t}$ \\
  $s_t$ & state & Share of tree $1$: $D_{1,t}/C_t$ \\
  $\bm{W}_t$ & process & $d$-dimensional Brownian motion \\
  $\bm{\sigma}_i$ & parameter & Diffusion loading for dividend $i$ \\
  $\mu_i$ & parameter & Drift of dividend $i$ \\
  $\rho$ & parameter & Subjective discount rate \\
  $\Lambda_t$ & process & Stochastic discount factor $e^{-\rho t} C_t^{-1}$ \\
  $r_t$ & scalar & Short rate $\rho+\mu_C(s_t)-\norm{\bm{\sigma}_C(s_t)}^2$ \\
  $\bm{\lambda}_t$ & vector & Market price of risk $\bm{\sigma}_C(s_t)$ \\
  $R$ & return & Generic asset return with diffusion $\bm{\sigma}_R$ \\
  \midrule
  \multicolumn{3}{l}{\textit{Derived coefficients (state-dependent on $s_t$)}} \\
  $\mu_C(s)$ & function & Drift of $\diff C_t/C_t$: $s\mu_1+(1-s)\mu_2$ \\
  $\bm{\sigma}_C(s)$ & function & Diffusion of $\diff C_t/C_t$: $s\bm{\sigma}_1+(1-s)\bm{\sigma}_2$ \\
  \bottomrule
  \end{tabular}
  \caption{Notation used throughout.}
\end{table}

\medskip
\noindent\textbf{Acronyms used in text:} \ac{BSDE}, \ac{FBSDE}, \ac{SDF}, \ac{CAPM}, \ac{PDE}, \ac{FOC}.
\medskip

\printacronyms

\clearpage
\section{Primitives and Assumptions}

\begin{assumption}{Two-Tree Lucas Environment}{lucas}
\begin{enumerate}[leftmargin=1.25em]
  \item Time is continuous on $[0,\infty)$ and uncertainty lives on a filtered probability space $(\Omega,\mathcal F,\{\mathcal F_t\},\mathbb P)$ supporting a $d$-dimensional Brownian motion $\bm W$.
  \item Each dividend process $D_{i,t}$, $i\in\{1,2\}$, evolves according to the geometric diffusion
  \begin{equation}\label{eq:dividend}
    \frac{\diff D_{i,t}}{D_{i,t}} = \mu_i\,\diff t + \bm{\sigma}_i^{\top}\diff \bm W_t,
  \end{equation}
  with constant drift $\mu_i\in\R$ and diffusion loading $\bm\sigma_i\in\R^d$. Initial dividends satisfy $D_{i,0}>0$.
  \item A representative household discounts at $\rho>0$ and has log utility over aggregate consumption,
  \[
    \E\Big[\int_0^{\infty} e^{-\rho t}\log C_t\,\diff t\Big], \qquad C_t \equiv D_{1,t}+D_{2,t}.
  \]
  \item Financial markets are frictionless and complete: the agent trades the equity claims on both trees and consumes the unique good each instant, so equilibrium consumption equals the sum of dividends.
\end{enumerate}
\end{assumption}

\begin{assumption}{State representation and admissibility}{ass:primitives}
\begin{enumerate}[label=(\roman*),itemsep=0.25em]
  \item \textbf{States.} $(D_{1,t},D_{2,t})\in\R_+^2$, aggregate consumption $C_t\in\R_+$, and share $s_t\in(0,1)$.
  \item \textbf{Shocks.} The covariance of dividend growth is $\Sigma\equiv[\bm\sigma_1,\bm\sigma_2][\bm\sigma_1,\bm\sigma_2]^{\top}$.
  \item \textbf{Parameters.} $\theta=(\rho,\mu_1,\mu_2,\bm\sigma_1,\bm\sigma_2)$ is constant. We assume $\rho>0$ and $\norm{\bm\sigma_i}<\infty$.
  \item \textbf{Admissibility.} Candidate price--dividend ratios $f^i(C,s)$ are $C^{1,2}$ in $(C,s)$, of at most linear growth in $C$, and trading strategies keep wealth processes integrable.
\end{enumerate}
\end{assumption}

\section{Mathematical Setup: State Dynamics and Generators}
\subsection{State space and transformations}
The primitive state is the dividend vector $\bm{D}_t=(D_{1,t},D_{2,t})\in\R_+^2$. Log utility implies homogeneity: aggregate consumption and the share
\begin{equation}\label{eq:state_transform}
  C_t=D_{1,t}+D_{2,t}, \qquad s_t=\frac{D_{1,t}}{C_t}\in(0,1)
\end{equation}
form a sufficient representation. The transformation $(D_1,D_2)\mapsto(C,s)$ is a bijection between $\R_+^2$ and $\R_+\times(0,1)$, verified in Appendix~\ref{app:lean_verification}.

\subsection{Dynamics of consumption and share}
Applying It\^o's lemma to the transformation \eqref{eq:state_transform} yields closed-form dynamics.

\begin{lemma}{Dynamics of aggregate consumption}{lem:C}
Aggregate consumption satisfies
\begin{align}
  \frac{\diff C_t}{C_t}
  &= \mu_C(s_t)\,\diff t + \bm{\sigma}_C(s_t)^{\top}\diff \bm{W}_t,
  \label{eq:C_drift}\\
  \mu_C(s) &\equiv s\mu_1+(1-s)\mu_2,
  \qquad
  \bm{\sigma}_C(s) \equiv s\bm{\sigma}_1+(1-s)\bm{\sigma}_2.
  \label{eq:sigmaC_def}
\end{align}
\end{lemma}
\begin{proof}
The differential of aggregate consumption is \mbox{$\diff C_t = \diff D_{1,t}+\diff D_{2,t}$}. Substituting the dividend dynamics from \cref{eq:dividend} gives
\[
  \diff C_t = (D_{1,t}\mu_1+D_{2,t}\mu_2)\,\diff t + (D_{1,t}\bm{\sigma}_1+D_{2,t}\bm{\sigma}_2)^{\top}\diff\bm{W}_t.
\]
Dividing by $C_t$ and using $s_t=D_{1,t}/C_t$ (so $D_{2,t}/C_t=1-s_t$) yields
\begin{align*}
  \frac{\diff C_t}{C_t}
  &= (s_t\mu_1+(1-s_t)\mu_2)\,\diff t + (s_t\bm{\sigma}_1+(1-s_t)\bm{\sigma}_2)^{\top}\diff\bm{W}_t \\
  &= \mu_C(s_t)\,\diff t + \bm{\sigma}_C(s_t)^{\top}\diff\bm{W}_t.
\end{align*}
\end{proof}

\begin{sympycheck}[title={Verification: Consumption dynamics}]
\begin{pyconsole}
import sympy as sp

s, mu1, mu2 = sp.symbols('s mu1 mu2', real=True)
sigma1, sigma2 = sp.symbols('sigma1 sigma2')

muC = s*mu1 + (1-s)*mu2
sigmaC = s*sigma1 + (1-s)*sigma2

left_drift = s*mu1 + (1-s)*mu2
left_sigma = s*sigma1 + (1-s)*sigma2

assert sp.simplify(left_drift - muC) == 0
assert sp.simplify(left_sigma - sigmaC) == 0
\end{pyconsole}
\end{sympycheck}

\begin{leanproof}[title={Affine structure of $\mu_C$ and $\bm{\sigma}_C$}]
The consumption coefficients are affine in the primitives.
\begin{lstlisting}[basicstyle=\ttfamily\small]
import Mathlib.Data.Real.Basic

lemma affine_mix (s x1 x2 : Real) :
    s * x1 + (1 - s) * x2 = x2 + s * (x1 - x2) := by
  ring
\end{lstlisting}
The identity specialises componentwise to $\bm{\sigma}_C(s)$.
\end{leanproof}

\begin{lemma}{Dynamics of the consumption share}{lem:s}
The share process obeys $\diff s_t = \mu_s(s_t)\,\diff t + \bm{\sigma}_s(s_t)^{\top}\diff\bm{W}_t$, where
\begin{align}
  \mu_s(s) &\equiv s(1-s)\Big(\mu_1-\mu_2+\bm{\sigma}_C(s)^{\top}(\bm{\sigma}_2-\bm{\sigma}_1)\Big), \\
  \bm{\sigma}_s(s) &\equiv s(1-s)(\bm{\sigma}_1-\bm{\sigma}_2).
  \label{eq:s_drift}
\end{align}
\end{lemma}
\begin{proof}
Apply It\^o's lemma to $s_t = D_{1,t}/C_t$. The quotient rule gives
\[
  \frac{\diff s_t}{s_t} = \Big(\frac{\diff D_{1,t}}{D_{1,t}}-\frac{\diff C_t}{C_t}\Big) + \Big(\norm{\bm{\sigma}_C(s_t)}^2 - \ip{\bm{\sigma}_1}{\bm{\sigma}_C(s_t)}\Big)\,\diff t.
\]
The relative-growth term expands to $(\mu_1-\mu_C(s_t))\,\diff t + (\bm{\sigma}_1-\bm{\sigma}_C(s_t))^{\top}\diff\bm{W}_t$. Using $\mu_C(s) = s\mu_1 + (1-s)\mu_2$ and $\bm{\sigma}_C(s) = s\bm{\sigma}_1 + (1-s)\bm{\sigma}_2$ we have
\[
  \mu_1-\mu_C(s) = (1-s)(\mu_1-\mu_2),
  \qquad
  \bm{\sigma}_1-\bm{\sigma}_C(s) = (1-s)(\bm{\sigma}_1-\bm{\sigma}_2).
\]
Similarly $\norm{\bm{\sigma}_C(s)}^2 - \ip{\bm{\sigma}_1}{\bm{\sigma}_C(s)} = (1-s)\bm{\sigma}_C(s)^{\top}(\bm{\sigma}_2-\bm{\sigma}_1)$. Multiplying the drift and diffusion contributions by $s_t$ delivers the stated expressions for $\mu_s(s)$ and $\bm{\sigma}_s(s)$.
\end{proof}

\begin{sympycheck}[title={Verification: Share dynamics}]
\begin{pyconsole}
import sympy as sp

s, mu1, mu2 = sp.symbols('s mu1 mu2', real=True)
sig1_sq, sig2_sq, sig1_sig2 = sp.symbols('sig1_sq sig2_sq sig1_sig2', real=True)

muC = s*mu1 + (1-s)*mu2
sigC_sq = s**2*sig1_sq + (1-s)**2*sig2_sq + 2*s*(1-s)*sig1_sig2
sig1_sigC = s*sig1_sq + (1-s)*sig1_sig2
sigC_sig2 = s*sig1_sig2 + (1-s)*sig2_sq

drift_ito = s*(mu1 - muC) + s*(sigC_sq - sig1_sigC)
drift_stated = s*(1-s)*(mu1 - mu2 + (sigC_sig2 - sig1_sigC))

assert sp.simplify(drift_ito - drift_stated) == 0
\end{pyconsole}
\end{sympycheck}

\begin{tcolorbox}[didacticstyle]
\textbf{Interpretation.} The share $s_t$ drifts toward the tree with higher expected growth $\mu_j$ and toward the tree with smaller exposure to aggregate risk. The factor $s_t(1-s_t)$ reflects the unit-sum constraint and keeps the process in $(0,1)$.
\end{tcolorbox}
\subsection{Generator in $(C,s)$ coordinates}
The diffusion $(C_t,s_t)$ has infinitesimal generator $\mathcal{L}$ acting on smooth functions $f(C,s)$ by
\[
  \mathcal{L}f = \mu_C C \partial_C f + \mu_s \partial_s f + \tfrac12 \norm{\bm{\sigma}_C}^2 C^2 \partial_{CC} f + \tfrac12 \norm{\bm{\sigma}_s}^2 \partial_{ss} f + (\bm{\sigma}_C\cdot\bm{\sigma}_s) C \partial_{Cs} f,
\]
where $\mu_s(s)$ and $\bm{\sigma}_s(s)$ are the drift and diffusion coefficients from the share dynamics result. This generator underpins the valuation equations in the following sections.

\section{Stochastic Discount Factor and CAPM}\label{sec:sdf}

\begin{proposition}{Two-tree log-utility SDF and CAPM}{prop:sdf}
The stochastic discount factor $\Lambda_t=e^{-\rho t}C_t^{-1}$ satisfies
\begin{equation}\label{eq:sdf_drift}
  \frac{\diff \Lambda_t}{\Lambda_t}=-(\rho+\mu_C(s_t)-\norm{\bm{\sigma}_C(s_t)}^2)\,\diff t-\bm{\sigma}_C(s_t)^{\top}\diff \bm{W}_t,
\end{equation}
so $r_t=\rho+\mu_C(s_t)-\norm{\bm{\sigma}_C(s_t)}^2$ and $\bm{\lambda}_t=\bm{\sigma}_C(s_t)$. Any return with diffusion $\bm{\sigma}_R$ obeys the CAPM relation
\begin{equation}\label{eq:capm}
  \E_t[\diff R_t]-r_t\,\diff t=\ip{\bm{\lambda}_t}{\bm{\sigma}_R}\,\diff t.
\end{equation}
\end{proposition}
\begin{proof}
We apply It\^o's lemma to the function $f(t, C) = e^{-\rho t} C^{-1}$. The derivatives are $\partial_t f = -\rho f$, $\partial_C f = -C^{-1} f$, $\partial_{CC} f = 2C^{-2} f$. Using $\diff C_t = C_t\mu_C\,\diff t + C_t\bm{\sigma}_C^{\top}\diff\bm{W}_t$ (suppressing $s_t$ for brevity), It\^o's lemma yields
\[
  \diff\Lambda_t = \partial_t f\,\diff t + \partial_C f\,\diff C_t + \tfrac12\,\partial_{CC} f\,\langle\diff C_t,\diff C_t\rangle_t.
\]
Since $\langle\diff C_t,\diff C_t\rangle_t = C_t^2\norm{\bm{\sigma}_C}^2\,\diff t$, we obtain
\begin{align*}
  \diff\Lambda_t
  &= -\rho\Lambda_t\,\diff t + (-C_t^{-1}\Lambda_t)(C_t\mu_C\,\diff t + C_t\bm{\sigma}_C^{\top}\diff\bm{W}_t) + \tfrac12(2 C_t^{-2}\Lambda_t)(C_t^2\norm{\bm{\sigma}_C}^2\,\diff t) \\
  &= \Lambda_t\Big[(-\rho-\mu_C+\norm{\bm{\sigma}_C}^2)\,\diff t - \bm{\sigma}_C^{\top}\diff\bm{W}_t\Big].
\end{align*}
Dividing by $\Lambda_t$ gives \cref{eq:sdf_drift}. Matching $\diff\Lambda_t/\Lambda_t = -r_t\,\diff t - \bm{\lambda}_t^{\top}\diff\bm{W}_t$ identifies $\bm{\lambda}_t=\bm{\sigma}_C(s_t)$ and $r_t=\rho+\mu_C(s_t)-\norm{\bm{\sigma}_C(s_t)}^2$. The CAPM statement follows from $\E_t[\diff R_t]-r_t\,\diff t=-\Cov_t(\diff\Lambda_t/\Lambda_t,\diff R_t)$.
\end{proof}

\begin{sympycheck}[title={Verification: SDF dynamics via It\^o's Lemma}]
\begin{pyconsole}
import sympy as sp

rho, muC, sigmaC_sq = sp.symbols('rho muC sigmaC_sq', real=True)
sigmaC = sp.symbols('sigmaC')
t, C = sp.symbols('t C', positive=True, real=True)

Lambda = sp.exp(-rho*t) * C**(-1)

dL_dt = sp.diff(Lambda, t)
dL_dC = sp.diff(Lambda, C)
dL_dCC = sp.diff(dL_dC, C)
drift = dL_dt + dL_dC * (C*muC) + sp.Rational(1,2) * dL_dCC * (C**2*sigmaC_sq)

normalized_drift = sp.simplify(drift / Lambda)
expected_drift = -rho - muC + sigmaC_sq
assert sp.simplify(normalized_drift - expected_drift) == 0

normalized_diffusion = sp.simplify((dL_dC * C*sigmaC) / Lambda)
assert sp.simplify(normalized_diffusion - (-sigmaC)) == 0
\end{pyconsole}
\end{sympycheck}

\begin{leanproof}[title={Structural Definition: Log-Utility SDF}]
We verify the structure $\Lambda_t = e^{-\rho t} u'(C_t)$ where $u(C) = \log C$.
\begin{lstlisting}[language={},basicstyle=\ttfamily\small]
import Mathlib.Analysis.SpecialFunctions.Log.Basic
import Mathlib.Analysis.Calculus.Deriv.Basic

noncomputable section
open Real

variable (rho : Real) (C : Real) (hC : C > 0)
def utility (C : Real) : Real := log C

lemma utility_deriv (hC : C > 0) : deriv utility C = 1/C := by
  simp [utility, deriv_log, hC.ne']

def sdf (t : Real) (C : Real) : Real := exp (-rho * t) * (deriv utility C)

lemma sdf_structure (t : Real) (hC : C > 0) :
  sdf rho t C = exp (-rho * t) * C^{-1} := by
  simp [sdf, utility_deriv hC, inv_eq_one_div]
\end{lstlisting}
\end{leanproof}

\begin{corollary}{Tree-level risk premia}{cor:capm_trees}
For the equity claim on tree $j\in\{1,2\}$ with return diffusion $\bm{\sigma}_{R^j}$, the risk premium is
\begin{equation}\label{eq:tree_capm}
  \E_t[\diff R^j_t]-r_t\,\diff t=\ip{\bm{\sigma}_C(s_t)}{\bm{\sigma}_{R^j}}\,\diff t.
\end{equation}
The risk-neutral drift of the dividend process $D_j$ (with physical drift $\mu_j$ and diffusion $\bm{\sigma}_j$) is
\begin{equation}\label{eq:rn_drift_cor}
  \mu_j^{\mathbb{Q}}(s_t)=\mu_j-\ip{\bm{\sigma}_j}{\bm{\sigma}_C(s_t)}.
\end{equation}
\end{corollary}
\begin{proof}
Set $\bm{\sigma}_R=\bm{\sigma}_{R^j}$ in \eqref{eq:capm} with $\bm{\lambda}_t=\bm{\sigma}_C(s_t)$. For the risk-neutral dynamics, apply Girsanov: $\diff\bm{W}_t^{\mathbb{Q}}=\diff\bm{W}_t+\bm{\lambda}_t\,\diff t$. Then
\[
  \frac{\diff D_{j,t}}{D_{j,t}}=\mu_j\,\diff t+\bm{\sigma}_j^{\top}(\diff\bm{W}_t^{\mathbb{Q}}-\bm{\lambda}_t\,\diff t)
  = (\mu_j-\ip{\bm{\sigma}_j}{\bm{\lambda}_t})\,\diff t + \bm{\sigma}_j^{\top}\diff\bm{W}_t^{\mathbb{Q}}.
\]
Substituting $\bm{\lambda}_t=\bm{\sigma}_C(s_t)$ yields \eqref{eq:rn_drift_cor}.
\end{proof}

\begin{tcolorbox}[didacticstyle]
	extbf{Economic reading.} The short rate combines time preference ($\rho$), expected consumption growth ($\mu_C$), and precautionary savings ($-\norm{\bm{\sigma}_C}^2$). The precautionary term carries coefficient one---not one-half---because log utility makes consumption the num\'eraire. Asset premia hinge on covariances with the consumption-weighted shock $\bm{\sigma}_C(s_t)$.
\end{tcolorbox}

\section{Risk-Neutral Dynamics and Valuation PDE}\label{sec:pde}
\begin{proposition}{Valuation PDE for tree $i$}{prop:valuation}
Let $P_i(D_1,D_2)$ denote the ex-dividend price of tree $i$. Under the risk-neutral measure induced by $\bm{\lambda}_t$, the drift of dividend $j$ becomes
\begin{equation}\label{eq:rn_drift}
  \mu_j^{\mathbb{Q}}(s) = \mu_j-\ip{\bm{\sigma}_j}{\bm{\sigma}_C(s)}, \quad j\in\{1,2\}.
\end{equation}
The valuation PDE reads
\begin{align}\label{eq:valuation_pde}
  r_t P_i &= D_i
   + \mu_1^{\mathbb{Q}} D_1\,\partial_{D_1} P_i
   + \mu_2^{\mathbb{Q}} D_2\,\partial_{D_2} P_i \\
  &\quad + \tfrac12 \norm{\bm{\sigma}_1}^2 D_1^2\,\partial^2_{D_1 D_1} P_i
   + \tfrac12 \norm{\bm{\sigma}_2}^2 D_2^2\,\partial^2_{D_2 D_2} P_i
   + \ip{\bm{\sigma}_1}{\bm{\sigma}_2} D_1 D_2\,\partial^2_{D_1 D_2} P_i.
\end{align}
\end{proposition}
\begin{proof}
Shift the dividend drifts by $-\ip{\bm{\sigma}_j}{\bm{\lambda}_t}$ and apply the standard valuation equation for dividend-paying securities.
\end{proof}

\begin{tcolorbox}[mathstyle]
\textbf{Diagnostic.} Correlated shocks ($\ip{\bm{\sigma}_1}{\bm{\sigma}_2}\neq0$) introduce the cross-derivative term, tightening the coupling between the two dividend streams. Orthogonal shocks decouple the PDEs.
\end{tcolorbox}

\section{Constant-Share Benchmark and CAPM Components}\label{sec:benchmark}
If the share $s_t$ is constant, the risk-neutral coefficients become constants and the solution to \eqref{eq:valuation_pde} collapses to
\begin{equation}\label{eq:const_share_solution}
  P_i = \frac{D_i}{r-\mu_i^{\mathbb{Q}}}, \qquad r>\mu_i^{\mathbb{Q}}.
\end{equation}
Defining
\begin{equation}\label{eq:beta}
  \beta_i \equiv \frac{\ip{\bm{\sigma}_i}{\bm{\sigma}_C}}{\norm{\bm{\sigma}_C}^2}
\end{equation}
recovers the familiar CAPM slope $\E_t[R_i]-r=\norm{\bm{\sigma}_C}^2\beta_i$ whenever $\norm{\bm{\sigma}_C}\neq0$.

\begin{tcolorbox}[didacticstyle]
\textbf{Economic intuition.} In the constant-share benchmark each tree replicates a levered claim on aggregate consumption. Trees with higher covariance with $\bm{\sigma}_C$ must offer higher expected returns, shrinking their price--dividend multiples.
\end{tcolorbox}

\section{Dimensionality Reduction and the Valuation ODE}\label{sec:reduction}

The structure of the Lucas economy with log utility allows for a significant dimensionality reduction from a 2D PDE to a 1D ODE.

\begin{proposition}{Homogeneity and Price--Dividend Ratios}{prop:homogeneity}
Prices are homogeneous of degree one in dividends. Consequently, the price of tree $i$ factorises as:
\begin{equation}\label{eq:pd_ratio}
  P_i(D_1,D_2) = D_i f_i(s_t), \qquad f_i:(0,1)\to\R_+,
\end{equation}
where $f_i(s)$ is the price--dividend ratio, depending only on the share $s_t$.
\end{proposition}
\begin{proof}
The SDF $\Lambda_t=e^{-\rho t}C_t^{-1}$ is homogeneous of degree $-1$ in $C_t$ (and thus in dividends). The price is $P_{i,t} = \E_t\big[\int_t^\infty (\Lambda_u/\Lambda_t) D_{i,u}\,\diff u\big]$. If all initial dividends are scaled by $\kappa>0$, $C_u$ scales by $\kappa$ for all $u\ge t$. The SDF ratio $\Lambda_u/\Lambda_t$ remains invariant, and $D_{i,u}$ scales by $\kappa$. Thus, $P_{i,t}$ scales linearly with $\kappa$. Since the dynamics of $s_t$ are independent of the level $C_t$, the resulting price--dividend ratio must depend only on $s_t$.
\end{proof}

To utilise this structure in the valuation PDE \eqref{eq:valuation_pde}, we require the dynamics of the state variable $s_t$ under the risk-neutral measure $\mathbb{Q}$.

\subsection{Risk-Neutral Dynamics of the Share Process}

\begin{lemma}{Risk-neutral share dynamics}{lem:sQ}
Under the risk-neutral measure $\mathbb{Q}$ induced by $\bm{\lambda}_t=\bm{\sigma}_C(s_t)$, the share process $s_t$ follows
\begin{equation}\label{eq:s_drift_Q}
  \diff s_t = \mu_s^{\mathbb{Q}}(s_t)\,\diff t + \bm{\sigma}_s(s_t)^{\top}\diff\bm{W}_t^{\mathbb{Q}},
\end{equation}
where the diffusion $\bm{\sigma}_s(s)=s(1-s)(\bm{\sigma}_1-\bm{\sigma}_2)$ is invariant under the change of measure, and the risk-neutral drift is
\begin{equation}\label{eq:mu_s_Q}
  \mu_s^{\mathbb{Q}}(s) = s(1-s)\Big(\mu_1^{\mathbb{Q}}(s)-\mu_2^{\mathbb{Q}}(s)+\bm{\sigma}_C(s)^{\top}(\bm{\sigma}_2-\bm{\sigma}_1)\Big).
\end{equation}
\end{lemma}
\begin{proof}
Under $\mathbb{P}$, $\diff s_t = \mu_s(s_t)\,\diff t + \bm{\sigma}_s(s_t)^{\top}\diff\bm{W}_t$. Using $\diff\bm{W}_t = \diff\bm{W}_t^{\mathbb{Q}} - \bm{\lambda}_t\,\diff t$ with $\bm{\lambda}_t=\bm{\sigma}_C(s_t)$,
\[
  \diff s_t = \big(\mu_s(s_t) - \ip{\bm{\sigma}_s(s_t)}{\bm{\sigma}_C(s_t)}\big)\,\diff t + \bm{\sigma}_s(s_t)^{\top}\diff\bm{W}_t^{\mathbb{Q}}.
\]
The adjustment equals $\ip{\bm{\sigma}_s(s)}{\bm{\sigma}_C(s)} = s(1-s)\ip{\bm{\sigma}_1-\bm{\sigma}_2}{\bm{\sigma}_C(s)}$. Substituting the expression for $\mu_s$ and regrouping using $\mu_j^{\mathbb{Q}}(s)$ yields \eqref{eq:mu_s_Q}.
\end{proof}

\begin{sympycheck}[title={Verification: Risk-neutral share drift $\mu_s^{\mathbb{Q}}(s)$}]
This verifies the algebraic equivalence between the Girsanov-transformed drift and the stated result using risk-neutral dividend drifts.
\begin{pyconsole}
import sympy as sp

s, mu1, mu2 = sp.symbols('s mu1 mu2', real=True)
# Define symbols for inner products <sigma_i, sigma_j>
sig1_sq, sig2_sq, sig1_sig2 = sp.symbols('sig1_sq sig2_sq sig1_sig2', real=True)

# Inner products involving sigmaC
sig1_sigC = s*sig1_sq + (1-s)*sig1_sig2
sigC_sig2 = s*sig1_sig2 + (1-s)*sig2_sq
# <sigmaC, sigma2-sigma1>
sigC_diff = sigC_sig2 - sig1_sigC

# Physical drift mu_s (Lemma 3.2)
mu_s = s*(1-s)*(mu1 - mu2 + sigC_diff)

# Girsanov adjustment: <sigma_s, lambda_t>
# sigma_s = s(1-s)(sigma1-sigma2). lambda_t = sigmaC.
# <sigma_s, sigmaC> = s(1-s) * (<sigma1, sigmaC> - <sigma2, sigmaC>)
adjustment = s*(1-s)*(sig1_sigC - sigC_sig2)

# LHS: Drift under Q via Girsanov
mu_s_Q_girsanov = mu_s - adjustment

# RHS: Stated drift under Q (Lemma 7.2)
mu1_Q = mu1 - sig1_sigC
mu2_Q = mu2 - sigC_sig2
mu_s_Q_stated = s*(1-s)*(mu1_Q - mu2_Q + sigC_diff)

# Verification
assert sp.simplify(mu_s_Q_girsanov - mu_s_Q_stated) == 0
\end{pyconsole}
\end{sympycheck}

\subsection{The Valuation ODE}

The infinitesimal generator $\mathcal{L}^{\mathbb{Q}}_s$ of the 1D diffusion $s_t$ under $\mathbb{Q}$ acts on smooth $g(s)$ as $\mathcal{L}^{\mathbb{Q}}_s g = a(s) g'' + b^{\mathbb{Q}}(s) g'$, where
\[
  a(s) = \tfrac12 \norm{\bm{\sigma}_s(s)}^2 = \tfrac12 s^2(1-s)^2\norm{\bm{\sigma}_1-\bm{\sigma}_2}^2,\qquad
  b^{\mathbb{Q}}(s)=\mu_s^{\mathbb{Q}}(s).
\]

\begin{theorem}{Valuation ODE for Price--Dividend Ratios}{thm:valuation_ode}
The price--dividend ratio $f_i(s)$ for tree $i$ satisfies the second-order linear ODE:
\begin{equation}\label{eq:ode_price}
  a(s) f_i''(s) + b^{\mathbb{Q}}(s) f_i'(s) - \big(r(s)-\mu_i^{\mathbb{Q}}(s)\big) f_i(s) + 1 = 0,
\end{equation}
where $a(s)$ and $b^{\mathbb{Q}}(s)$ are defined above, and $r(s)$ and $\mu_i^{\mathbb{Q}}(s)$ are as defined earlier.
\end{theorem}
\begin{proof}
Substitute the ansatz $P_i(D_1,D_2)=D_i f_i(s)$ into \eqref{eq:valuation_pde} and exploit homogeneity, or equivalently apply Feynman--Kac to the martingale pricing condition under $\mathbb{Q}$.
\end{proof}

\begin{tcolorbox}[mathstyle]
	extbf{Boundary behaviour and Feller's classification.} The diffusion coefficient $a(s)$ vanishes quadratically as $s\to0$ or $s\to1$. Assuming $\bm{\sigma}_1\neq\bm{\sigma}_2$, $a(s)>0$ on $(0,1)$, so the process is regular internally. Feller's classification indicates that $s=0$ and $s=1$ are natural boundaries (inaccessible in finite time), confirming $s_t\in(0,1)$.
\end{tcolorbox}

\section{Boundary and Regularity Conditions}
The ODE \eqref{eq:ode_price} is solved subject to Dirichlet boundary conditions. As $s\to 1$ (Tree 2 vanishes), $C_t\approx D_{1,t}$. Tree 1 becomes the market with price--dividend ratio $1/\rho$, while Tree 2 is worthless; the roles reverse as $s\to0$:
\[
  f_1(1)=1/\rho, \quad f_1(0)=0; \qquad f_2(0)=1/\rho, \quad f_2(1)=0.
\]
Homogeneity ensures $P_i(D_1,D_2)=D_i f_i(s)$ grows at most linearly in dividends provided the discount rate is sufficiently high, specifically $\rho>\sup_s \mu_i^{\mathbb{Q}}(s)$. This condition also guarantees transversality.

\begin{tcolorbox}[didacticstyle]
Extremes $s\to0$ or $1$ correspond to one tree vanishing. The boundary data encode that the surviving tree reverts to the single-tree Lucas benchmark while the disappearing tree is worthless.
\end{tcolorbox}

\section{Computation: Solution Strategies}\label{sec:computation}
The numerical task is to recover the price--dividend ratios $f_i(s)$ by solving the coupled boundary value problem \eqref{eq:ode_price}. We first summarise the established numerical solvers for this benchmark before turning to modern probabilistic methods that scale to higher dimensions.

\subsection{Classical ODE/PDE Methods}\label{sec:computation_classical}
The boundary-value problem \eqref{eq:ode_price} is linear and one-dimensional, so established discretisations remain powerful:
\begin{enumerate}[leftmargin=1.25em]
  \item \textbf{Finite Differences (FD).} Discretise the domain $s\in[0,1]$ into $N+1$ points. Derivatives in \cref{eq:ode_price} are approximated using finite-difference stencils. Central differences offer second-order accuracy for diffusion. For the drift term $b^{\mathbb{Q}}(s) f'(s)$, upwind schemes are typically required to ensure stability, especially when drift dominates diffusion (high P\'eclet number).
  \item \textbf{Finite Volume Methods (FVM).} FVM integrates the equation over control volumes and approximates fluxes across cell faces. By enforcing the balance of fluxes, FVM preserves conservation properties and remains robust when coefficients degenerate near the boundaries $s=0,1$. FVM is also notably flexible for extensions involving high-dimensional or infinite-dimensional controls \cite{chen2025applications}.
  \begin{tcolorbox}[literaturestyle, title={FVM for Continuum Controls}]
  \cite{chen2025applications} demonstrate FVM when controls or states form a continuum (e.g., debt maturity profiles). FVM approximates the continuous function by step functions over discretised intervals (volumes), converting an infinite-dimensional problem to a high-dimensional one suitable for probabilistic solvers (\cref{sec:computation_probabilistic}) while remaining robust under complex asymptotics (e.g., Pareto tails).
  \end{tcolorbox}
  \item \textbf{System structure and complexity.} Both FD and FVM discretisations yield a linear system $A\bm{f}_i=\bm{b}$. The locality of the differential operators implies that $A$ is sparse and typically tridiagonal, enabling the Thomas algorithm to solve the system in $O(N)$ time.
  \begin{sympycheck}[title={Verification: Tridiagonal structure from 1D discretisation}]
  \small Standard FD stencils (e.g., centred differences for diffusion, upwinding for drift) only couple adjacent grid points ($j-1, j, j+1$), ensuring that $A$ is tridiagonal. Appendix~\ref{app:sympy} records a symbolic confirmation.
  \end{sympycheck}
  \item \textbf{Spectral/Collocation Methods.} For smooth coefficients, expanding $f_i$ in a global polynomial basis (Chebyshev) and enforcing the ODE at collocation points achieves exponential convergence.
\end{enumerate}
\begin{tcolorbox}[didacticstyle, title={Computational benchmark}]
For the two-tree Lucas model, these classical methods deliver highly accurate solutions within milliseconds on standard hardware. They form the ground truth against which modern probabilistic methods (\cref{sec:computation_probabilistic}) are validated in low dimensions.
\end{tcolorbox}

\subsection{Modern Probabilistic Methods (Deep BSDE)}\label{sec:computation_probabilistic}
High-dimensional extensions---multiple trees, stochastic volatility, heterogeneous agents---render grid-based PDE methods impractical because of the curse of dimensionality. Reformulating the valuation problem as a forward--backward SDE enables simulation-based solvers such as the Deep BSDE method \cite{han2018solving,huang2025probabilistic}.
\begin{tcolorbox}[literaturestyle]
  extbf{Motivation for probabilistic solvers.} The BSDE formulation avoids the high-dimensional Hessians required by PDE solvers (and PINNs), yielding nearly linear complexity growth in state dimension while preserving martingale structure \cite{huang2025probabilistic}.
\end{tcolorbox}
\begin{proposition}{FBSDE representation for tree $i$}{prop:fbsde}
Let $P_t^i=C_t f_i(s_t)$ denote the price of tree $i$. The system $(C_t,s_t,P_t^i,\bm{Z}_t^i)$ solves the coupled FBSDE
\begin{align*}
  \diff C_t &= C_t\,\mu_C(s_t)\,\diff t + C_t\,\bm{\sigma}_C(s_t)^{\top}\diff\bm{W}_t,\\
  \diff s_t &= \mu_s(s_t)\,\diff t + \bm{\sigma}_s(s_t)^{\top}\diff\bm{W}_t,\\
  \diff P_t^i &= (r_t P_t^i - D_t^i)\,\diff t + (\bm{Z}_t^i)^{\top}\diff\bm{W}_t^{\mathbb{Q}} && (\text{under }\mathbb{Q})\\
              &= \big(r_t P_t^i - D_t^i + (\bm{Z}_t^i)^{\top}\bm{\lambda}_t\big)\,\diff t + (\bm{Z}_t^i)^{\top}\diff\bm{W}_t && (\text{under }\mathbb{P}),
\end{align*}
where $\bm{\lambda}_t=\bm{\sigma}_C(s_t)$ is the market price of risk and $\bm{Z}_t^i$ is the diffusion exposure ensuring that discounted prices remain martingales.
\end{proposition}
\begin{proof}
The forward dynamics follow from the derived dynamics of $C_t$ and $s_t$. Pricing under $\mathbb{Q}$ satisfies the linear BSDE with driver $(r_t P_t^i-D_t^i)$. Girsanov's theorem ($\diff\bm{W}_t^{\mathbb{Q}} = \diff\bm{W}_t + \bm{\lambda}_t\,\diff t$) then yields the $\mathbb{P}$-drift adjustment $(\bm{Z}_t^i)^{\top}\bm{\lambda}_t$.

To identify $\bm{Z}_t^i$, apply It\^o's lemma to the Markov representation $P_t^i(C_t, s_t)=C_t f_i(s_t)$. (Here $f_i$ denotes the price--consumption ratio; this differs from the price--dividend ratio in \cref{sec:reduction}.) The partial derivatives are $\partial_C P^i = f_i(s_t)$ and $\partial_s P^i = C_t f_i'(s_t)$. Using the diffusions of $C_t$ ($C_t\bm{\sigma}_C(s_t)$) and $s_t$ ($\bm{\sigma}_s(s_t)$) gives
\[
  \bm{Z}_t^i = f_i(s_t)\,C_t\bm{\sigma}_C(s_t) + C_t f_i'(s_t)\,\bm{\sigma}_s(s_t).
\]
\end{proof}

\begin{leanproof}[title={Algebraic Structure of Girsanov Drift Adjustment}]
We verify the structure of the drift adjustment when moving from $\mathbb{Q}$ to $\mathbb{P}$.
\begin{lstlisting}[language={},basicstyle=\ttfamily\small]
import Mathlib.Data.Real.Basic

variable (r P D : Real)
variable (Z_lambda_product : Real) -- Represents the inner product <Z, lambda>

-- Drift under Q (driver of the BSDE)
def drift_Q (r P D : Real) : Real := r * P - D

-- Drift under P (Girsanov adjusted)
def drift_P (r P D : Real) (Z_lambda_product : Real) : Real :=
  drift_Q r P D + Z_lambda_product

lemma drift_P_structure_verified :
    drift_P r P D Z_lambda_product = (r * P - D) + Z_lambda_product := by
  simp [drift_P, drift_Q]
\end{lstlisting}
\end{leanproof}

\begin{sympycheck}[title={Verification of diffusion exposure $\bm{Z}_t^i$}]
We verify the application of the chain rule (It\^o diffusion part) to $P_t^i = C_t f_i(s_t)$.
\begin{pyconsole}
import sympy as sp

C, s = sp.symbols('C s', positive=True, real=True)
sigma_C, sigma_s = sp.symbols('sigma_C sigma_s')
f_i = sp.Function('f_i')

P_i = C * f_i(s)
Z_ito = sp.diff(P_i, C) * (C * sigma_C) + sp.diff(P_i, s) * sigma_s
Z_stated = f_i(s) * (C * sigma_C) + (C * sp.diff(f_i(s), s)) * sigma_s
assert sp.simplify(Z_ito - Z_stated) == 0
\end{pyconsole}
\end{sympycheck}

The Deep BSDE algorithm solves this system by approximating the unknown functions $f_i(s)$ and $f_i'(s)$ using neural networks parameterised by $\Theta$.
\begin{enumerate}[leftmargin=1.25em]
  \item \textbf{Approximation and Automatic Differentiation.} Represent $f_i(s;\Theta)$; obtain $f_i'(s;\Theta)$ via automatic differentiation to compute $\bm{Z}_t^i$.
  \item \textbf{Simulation.} Simulate the forward components $(C_t, s_t)$ and the backward component $P_t^i$ (using the approximated $\bm{Z}_t^i$) forward in time.
  \item \textbf{Infinite-Horizon Adaptation.} Without a terminal condition, minimise a pathwise loss enforcing $P_k^m \approx C_k^m f_i(s_k^m;\Theta)$ at every step (Forward Euler Scheme), following \cite{huang2025probabilistic}. This drives convergence to the time-homogeneous fixed point.
\end{enumerate}
Appendix~\ref{app:algorithms} provides algorithmic details and stabilisation techniques (batching, antithetic pairing).

\section{Verification and Diagnostics}\label{sec:verification}

Model implementations should report the calibration, seeds, and numerical tolerances; track martingale diagnostics for $\Lambda_t P_t^i$; and compare simulated moments of $(C_t,s_t)$ against analytical targets. Appendix~\ref{app:sympy} runs executable SymPy checks for core lemmas and propositions, while Appendix~\ref{app:lean_verification} certifies the state transformation bijection in Lean4.

\section{Economic Remarks}
Log utility keeps prices proportional to dividends, so all cross-sectional variation in valuations flows through the share $s_t$. Higher dispersion in dividend growth rates pushes $s_t$ toward the dominant tree, raising that tree's expected return through \eqref{eq:tree_capm}. Correlated shocks magnify this channel via $\bm{\sigma}_C(s_t)$, while perfectly correlated trees reduce the model to a single Lucas tree with aggregate diffusion $\bm{\sigma}_C$.

\appendix
\section{Appendix A: Formal Verification (Lean4)}\label{app:lean_verification}
\begin{leanproof}
\begin{lstlisting}[basicstyle=\ttfamily\small]
import Mathlib.Data.Real.Basic

-- ASCII-only sketch to avoid Unicode in LaTeX
-- State spaces
structure DSpace :=
  (d : Prod Real Real)
  (pos1 : d.fst > 0)
  (pos2 : d.snd > 0)

structure CSSpace :=
  (cs : Prod Real Real)  -- (C, s)
  (c_pos : cs.fst > 0)
  (s_pos : cs.snd > 0)
  (s_lt_one : cs.snd < 1)

-- Forward map (D -> (C,s))
def transform (d : DSpace) : CSSpace :=
  let C := d.d.fst + d.d.snd
  let s := d.d.fst / C
  have hC : C > 0 := by
    have h1 : d.d.fst > 0 := d.pos1
    have h2 : d.d.snd > 0 := d.pos2
    have : C = d.d.fst + d.d.snd := rfl
    nlinarith
  have hs_pos : s > 0 := by exact div_pos d.pos1 hC
  have hs_lt_one : s < 1 := by
    have hlt : d.d.fst < C := by nlinarith
    -- using div_lt_one_of_lt for positive denominator C
    have hcpos : 0 < C := hC
    simpa [s] using (div_lt_one_of_lt hlt)
  { cs := (C, s), c_pos := hC, s_pos := hs_pos, s_lt_one := hs_lt_one }

-- Inverse map ((C,s) -> D)
def inverseTransform (cs : CSSpace) : DSpace :=
  let d1 := cs.cs.fst * cs.cs.snd
  let d2 := cs.cs.fst * (1 - cs.cs.snd)
  have hd1 : d1 > 0 := mul_pos cs.c_pos cs.s_pos
  have hd2 : d2 > 0 := by
    have h01 : 0 < 1 - cs.cs.snd := sub_pos.mpr cs.s_lt_one
    exact mul_pos cs.c_pos h01
  { d := (d1, d2), pos1 := hd1, pos2 := hd2 }

-- Bijection (sketch)
lemma transform_bijective : Function.Bijective transform := by
  refine And.intro ?inj ?surj
  -- inj
  intro x y h
    have : (transform x).cs = (transform y).cs := by simpa using congrArg CSSpace.cs h
    have hC : x.d.fst + x.d.snd = y.d.fst + y.d.snd := by simpa [transform] using congrArg Prod.fst this
    have hs : x.d.fst / (x.d.fst + x.d.snd) = y.d.fst / (y.d.fst + y.d.snd) := by
      simpa [transform] using congrArg Prod.snd this
    -- Omitted algebraic details in this sketch
    admit
  -- surj
  intro y
    refine Exists.intro (inverseTransform y) ?h
    -- Omitted: extensionality proof
    admit
\end{lstlisting}
\end{leanproof}


% (Moved the Girsanov drift adjustment check into the main text; see Section~\ref{sec:computation_probabilistic}.)

\section{Appendix B: Symbolic Verification (PythonTeX + SymPy)}\label{app:sympy}
\begin{sympycheck}
\begin{pyconsole}
import sympy as sp

s = sp.symbols('s', real=True)
mu1, mu2, rho = sp.symbols('mu1 mu2 rho', real=True)
# Abstract inner products for diffusion loadings
sig1_sq, sig2_sq, sig1_sig2 = sp.symbols('sig1_sq sig2_sq sig1_sig2', real=True)

muC = s*mu1 + (1-s)*mu2
sigC_sq = s**2 * sig1_sq + (1-s)**2 * sig2_sq + 2*s*(1-s)*sig1_sig2
sig1_sigC = s*sig1_sq + (1-s)*sig1_sig2
sigC_sig2 = s*sig1_sig2 + (1-s)*sig2_sq

# Share drift: Ito result vs intended formula
lhs = s*(mu1 - muC) + s*(sigC_sq - sig1_sigC)
rhs = s*(1-s)*(mu1 - mu2 + (sigC_sig2 - sig1_sigC))
assert sp.simplify(lhs - rhs) == 0

# Short rate correction
short_rate = rho + muC - sigC_sq
lhs_rate = rho + muC - sigC_sq
assert sp.simplify(short_rate - lhs_rate) == 0

print("All symbolic checks passed.")
\end{pyconsole}
\end{sympycheck}


\begin{sympycheck}[title={Verification: Tridiagonal structure from 1D discretization (Sec.~\ref{sec:computation_classical})}]
\begin{pyconsole}
import sympy as sp

# Define symbols for the grid and coefficients
j = sp.symbols('j', integer=True)
h = sp.symbols('h', real=True, positive=True)  # Grid spacing
a_j, b_j, c_j = sp.symbols('a_j b_j c_j', real=True)  # Coefficients at point j
f_jm1, f_j, f_jp1 = sp.symbols('f_jm1 f_j f_jp1')  # Function values

# Standard central difference stencil for a*f'' + b*f' - c*f = -1
# (Using central difference for advection as an example; upwinding yields the same dependence structure)
diffusion = a_j * (f_jp1 - 2*f_j + f_jm1) / h**2
advection = b_j * (f_jp1 - f_jm1) / (2*h)
reaction = -c_j * f_j

equation_j = diffusion + advection + reaction + 1

# Verify that the equation only depends on j-1, j, and j+1
dependencies = equation_j.free_symbols.intersection({f_jm1, f_j, f_jp1})
expected_dependencies = {f_jm1, f_j, f_jp1}

print(f"Dependencies at row j: {dependencies}")
assert dependencies == expected_dependencies
\end{pyconsole}
\end{sympycheck}

\section{Appendix C: Computational Algorithms}\label{app:algorithms}

\begin{tcolorbox}[float, title={Algorithm 1: Deep BSDE Training Loop (Infinite-Horizon Adaptation)}, label={alg:deepbsde}]
\small
\textbf{Goal:} Find neural network parameters $\Theta$ approximating $f_i(s;\Theta)$ and $\nabla_s f_i(s;\Theta)$.

\textbf{Input:} FBSDE coefficients $(\mu_C,\bm{\sigma}_C,\mu_s,\bm{\sigma}_s,r,\bm{\lambda})$, time steps $N$, step size $\Delta t$, batch size $M$.

\begin{enumerate}[leftmargin=1.5em,itemsep=0.5em]

  \item Initialise network parameters $\Theta$.

  \item \textbf{repeat} (optimisation epoch)

    \item \quad Sample initial states $\{(C_0^m,s_0^m)\}_{m=1}^M$. Set $P_0^m = C_0^m f_i(s_0^m;\Theta)$.

  \item \quad \textbf{for} $k=0$ to $N-1$ \textbf{do}

    \item \quad\quad Draw shocks $\{\Delta\bm{W}_k^m\}_{m=1}^M$ (e.g., Gaussian with antithetic sampling for variance reduction).

  \item \quad\quad Compute controls $\bm{Z}_k^m$ using the expression above. This requires $f_i'(s_k^m;\Theta)$, obtained via automatic differentiation of the network.

    \item \quad\quad Update states with Euler--Maruyama:

      \item \quad\quad\quad $C_{k+1}^m \leftarrow C_k^m + C_k^m \mu_C(s_k^m)\Delta t + C_k^m \bm{\sigma}_C(s_k^m)^{\top}\Delta\bm{W}_k^m$.

      \item \quad\quad\quad $s_{k+1}^m \leftarrow s_k^m + \mu_s(s_k^m)\Delta t + \bm{\sigma}_s(s_k^m)^{\top}\Delta\bm{W}_k^m$.

      \item \quad\quad Update prices (Backward SDE simulated forward under $\mathbb{P}$):

      \item \quad\quad\quad $P_{k+1}^m \leftarrow P_k^m + \big(r_k P_k^m - D_k^m + (\bm{Z}_k^m)^{\top}\bm{\lambda}_k\big)\Delta t + (\bm{Z}_k^m)^{\top}\Delta\bm{W}_k^m$.

  \item \quad \textbf{end for}

    \item \quad Compute the loss function. In the infinite-horizon setting, the loss enforces the Markov property $P_k^m \approx C_k^m f_i(s_k^m;\Theta)$ at all steps (Forward Euler Scheme, see \cite{huang2025probabilistic}):

  \begin{equation*}
    \mathcal{L}(\Theta) = \frac{1}{MN}\sum_{m=1}^M\sum_{k=1}^N \big\lVert P_k^m - C_k^m f_i(s_k^m;\Theta) \big\rVert^2.
  \end{equation*}

    \item \quad Update $\Theta$ with stochastic gradients (e.g. Adam) and apply diagnostics from Section~\ref{sec:verification}.

  \item \textbf{until} convergence.

\end{enumerate}

\textbf{Note:} This adaptation follows the methodology in \cite{han2018solving,huang2025probabilistic}. Complexity scales almost linearly with dimension by avoiding Hessian computations. Stabilization techniques (batching, antithetic sampling) are crucial for training.

\end{tcolorbox}


\section*{References}
\begin{thebibliography}{99}\small
\bibitem{breeden1979} Breeden, D. T. (1979).
An intertemporal asset pricing model with stochastic consumption and investment opportunities.
\emph{Journal of Financial Economics}, 7(3), 265--296.

\bibitem{chen2025applications} Chen, H., \& J. Huang (2025).
Applications of deep learning-based probabilistic approaches to economic models with high-dimensional controls.
Working paper, Chinese University of Hong Kong.

\bibitem{cochrane2005} Cochrane, J. H. (2005).
\emph{Asset Pricing: Revised Edition}.
Princeton University Press.

\bibitem{han2018solving} Han, J., A. Jentzen, \& W. E (2018).
Solving high-dimensional partial differential equations using deep learning.
\emph{Proceedings of the National Academy of Sciences}, 115(34), 8505--8510.

\bibitem{hansen2009} Hansen, L. P., \& J. Scheinkman (2009).
Long-term risk: an operator approach.
\emph{Econometrica}, 77(1), 177--234.

\bibitem{huang2025probabilistic} Huang, J. (2025).
A probabilistic solution to high-dimensional continuous-time macro and finance models.
CESifo Working Paper No.~10600.

\bibitem{lucas1978} Lucas Jr, R. E. (1978).
Asset prices in an exchange economy.
\emph{Econometrica}, 46(6), 1429--1445.
\end{thebibliography}

\end{document}

